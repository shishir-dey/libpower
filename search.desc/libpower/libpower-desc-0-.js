searchState.loadedDescShard("libpower", 0, "libpower - A no_std Rust library for power electronics, …\nDigital Control Systems\nDigital Signal Processing Filters\nMaximum Power Point Tracking (MPPT) Algorithms\nState of Charge (SoC) Estimation using Extended Kalman …\nExtended Kalman Filter-based State of Charge estimator for …\nBattery information and metadata\nComplete battery parameter set loaded from TOML\nPolynomial coefficients for battery parameter calculations\nCalculates internal resistance as a function of SoC using …\nCalculates open circuit voltage as a function of SoC using …\nCalculates RC circuit parameters as a function of SoC …\nCalculates the derivative of open circuit voltage with …\nCreates a SoC estimator with default parameters.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLoad battery parameters from a TOML string\nGets the battery information and metadata.\nGets the current estimated State of Charge.\nGets the current error covariance for the SoC estimate.\nGets the voltage across the first RC circuit.\nGets the voltage across the second RC circuit.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad a specific battery type by filename (without .toml …\nLoad battery parameters from embedded TOML data\nCreates a new SoC estimator with specified parameters …\nResets the estimator to initial conditions.\nSets the coulombic efficiency.\nSets the measurement noise parameter (R).\nSets the process noise parameter (Q).\nUpdates the SoC estimate using Extended Kalman Filter.\nCreates a new SoC estimator with specified battery type.\nTwo-Pole Two-Zero (2P2Z) Digital Compensator\nThree-Pole Three-Zero (3P3Z) Digital Compensator\nProportional-Integral (PI) Controller\nProportional-Integral-Derivative (PID) Controller\nConfiguration structure for 2P2Z compensator coefficients.\nTwo-pole, two-zero digital compensator for advanced …\nState variables for the 2P2Z compensator.\nCalculates the controller output for given reference and …\nFirst-order denominator coefficient (a₁)\nSecond-order denominator coefficient (a₂)\nZero-order numerator coefficient (b₀)\nFirst-order numerator coefficient (b₁)\nSecond-order numerator coefficient (b₂)\nCreates coefficients with all values set to zero and no …\nCreates variables with all state values initialized to …\nCurrent error (e(k))\nPrevious error (e(k-1))\nSecond previous error (e(k-2))\nFeedback signal\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the current error signal.\nGets the current controller output.\nLower integrator limit (typically unused in 2P2Z)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpper output saturation limit\nLower output saturation limit\nCreates a new 2P2Z controller with the specified …\nCreates a new coefficient structure with default (zero) …\nCreates a new variables structure with all state values …\nCurrent controller output\nPrevious controller output (u(k-1))\nSecond previous controller output (u(k-2))\nReference input signal\nResets all internal state variables to zero.\nSets the reference input and feedback values.\nCreates coefficients with example values suitable for …\nConfiguration structure for 3P3Z compensator coefficients.\nThree-pole, three-zero digital compensator for advanced …\nState variables for the 3P3Z compensator.\nCalculates the controller output for given reference and …\nFirst-order denominator coefficient (a₁)\nSecond-order denominator coefficient (a₂)\nThird-order denominator coefficient (a₃)\nZero-order numerator coefficient (b₀)\nFirst-order numerator coefficient (b₁)\nSecond-order numerator coefficient (b₂)\nThird-order numerator coefficient (b₃)\nCreates coefficients with all values set to zero and no …\nCreates variables with all state values initialized to …\nCurrent error (e(k))\nPrevious error (e(k-1))\nSecond previous error (e(k-2))\nThird previous error (e(k-3))\nFeedback signal\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the current error signal.\nGets the current controller output.\nLower integrator limit (typically unused in 3P3Z)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpper output saturation limit\nLower output saturation limit\nCreates a new 3P3Z controller with the specified …\nCreates a new coefficient structure with default (zero) …\nCreates a new variables structure with all state values …\nCurrent controller output\nPrevious controller output (u(k-1))\nSecond previous controller output (u(k-2))\nThird previous controller output (u(k-3))\nReference input signal\nResets all internal state variables to zero.\nSets the reference input and feedback values.\nCreates coefficients with example values suitable for …\nProportional-Integral (PI) controller with anti-windup …\nCalculates the controller output for given reference and …\nCreates a PI controller with default parameters.\nReturns the argument unchanged.\nGets the current integral term value.\nGets the current integral gain (Ki).\nGets the current proportional gain (Kp).\nGets the current controller output.\nGets the current proportional term value.\nCalls <code>U::from(self)</code>.\nCreates a new PI controller with default parameters.\nResets all internal state variables to zero.\nSets the proportional and integral gains.\nSets the output saturation limits.\nCreates a PI controller with specified gains.\nProportional-Integral-Derivative (PID) controller.\nGets the accumulated error (integral term accumulator).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGets the last measured position value.\nCreates a new PID controller with specified gains.\nResets all internal state variables to their initial …\nUpdates the PID controller and calculates the control …\nButterworth High-Pass Filter\nButterworth Low-Pass Filter\nChebyshev Type I High-Pass Filter\nChebyshev Type I Low-Pass Filter\nButterworth high-pass filter implemented using cascaded …\nReturns the argument unchanged.\nGets the number of second-order sections.\nGets the filter order.\nGets the current state variables (w0) for all sections.\nGets the first delayed state variables (w1) for all …\nGets the second delayed state variables (w2) for all …\nInitializes the filter with specified parameters.\nCalls <code>U::from(self)</code>.\nCreates an uninitialized filter instance.\nProcesses a single input sample through the filter.\nResets all filter state variables to zero.\nButterworth low-pass filter implemented using cascaded …\nReturns the argument unchanged.\nGets the number of second-order sections.\nGets the filter order.\nGets the current state variables (w0) for all sections.\nGets the first delayed state variables (w1) for all …\nGets the second delayed state variables (w2) for all …\nInitializes the filter with specified parameters.\nCalls <code>U::from(self)</code>.\nCreates an uninitialized filter instance.\nProcesses a single input sample through the filter.\nResets all filter state variables to zero.\nChebyshev Type I high-pass filter implemented using …\nReturns the argument unchanged.\nGets the number of second-order sections.\nGets the current state variables (w0) for all sections.\nGets the first delayed state variables (w1) for all …\nGets the second delayed state variables (w2) for all …\nInitializes the filter with specified parameters.\nCalls <code>U::from(self)</code>.\nCreates an uninitialized filter instance.\nProcesses a single input sample through the filter.\nResets all filter state variables to zero.\nChebyshev Type I low-pass filter implemented using …\nReturns the argument unchanged.\nGets the number of second-order sections.\nGets the current state variables (w0) for all sections.\nGets the first delayed state variables (w1) for all …\nGets the second delayed state variables (w2) for all …\nInitializes the filter with specified parameters.\nCalls <code>U::from(self)</code>.\nCreates an uninitialized filter instance.\nProcesses a single input sample through the filter.\nResets all filter state variables to zero.\nIncremental Conductance (IC) MPPT Algorithm\nPerturb and Observe (P&amp;O) MPPT Algorithm\nIncremental Conductance MPPT controller implementation.\nExecutes one iteration of the Incremental Conductance MPPT …\nCreates a new MPPT controller with default parameters.\nReturns the argument unchanged.\nGets the current voltage reference output.\nGets the current PV current measurement.\nGets the high current limit.\nGets the current PV voltage measurement.\nGets the high voltage limit.\nCalls <code>U::from(self)</code>.\nCreates a new IC MPPT controller with default parameters.\nSets the maximum voltage reference limit.\nSets the minimum voltage reference limit.\nSets the voltage perturbation step size.\nPerturb and Observe MPPT controller implementation.\nExecutes one iteration of the P&amp;O MPPT algorithm.\nCreates a new MPPT controller with default parameters.\nReturns the argument unchanged.\nGets the current voltage reference output.\nGets the current PV current measurement.\nGets the current PV power calculation.\nGets the current PV voltage measurement.\nCalls <code>U::from(self)</code>.\nCreates a new P&amp;O MPPT controller with default parameters.\nSets the maximum voltage reference limit.\nSets the minimum voltage reference limit.\nSets the voltage perturbation step size.\nSingle-Phase SOGI-PLL (Second Order Generalized Integrator …\nSingle-phase SOGI-PLL implementation for grid …\nExecutes one iteration of the SOGI-PLL algorithm.\nCreates a new SOGI-PLL with default parameters (50Hz, …\nReturns the argument unchanged.\nGets the current estimated frequency.\nGets the current angular frequency.\nGets the current estimated phase.\nGets the current phase error.\nGets the in-phase component (α) from SOGI.\nGets the quadrature component (β) from SOGI.\nCalls <code>U::from(self)</code>.\nCreates a new SOGI-PLL with specified parameters.\nResets the PLL to initial conditions.\nSets the PI controller gains for the PLL.\nSets the SOGI gain (damping factor).\nSignal Generation and Analysis Module\nConstant DC signal: f(t) = amplitude\nFull-wave rectified sine: f(t) = amplitude × |sin(2πft + …\nHalf-wave rectified sine: f(t) = amplitude × max(0, …\nPWM signal with configurable duty cycle\nSawtooth wave: Linear ramp with sharp reset\nSignal generator and analyzer for power electronics …\nComprehensive signal quality metrics.\nSignal type enumeration for waveform generation.\nSinusoidal signal: f(t) = amplitude × sin(2πft + φ)\nSquare wave: Alternating high and low levels\nTriangular wave: Linear ramp up and down\nAC RMS value (excluding DC)\nAverage value (DC component)\nCrest factor (peak amplitude / RMS)\nDC RMS value\nNegative duty cycle (fraction of time below zero)\nPositive duty cycle (fraction of time above zero)\nFall time (90% to 10% of amplitude)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the computed signal metrics.\nGets a reference to the generated sample buffer.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum sample value\nMinimum sample value\nCreates a new signal generator with specified parameters.\nPeak-to-peak amplitude (max - min)\nRise time (10% to 90% of amplitude)\nSets the duty cycle for PWM signals.\nSets the phase offset for the signal.\nTotal Harmonic Distortion percentage\nClarke Transformation (abc → αβ0)\nInverse Clarke Transformation (αβ0 → abc)\nInverse Park Transformation (dq0 → αβ0)\nPark Transformation (αβ0 → dq0)\nThree-phase to two-phase Clarke transformation.\nResult structure for Clarke transformation calculations.\nAlpha component (α) - aligned with phase A\nCalculates the phase angle of the αβ vector.\nBeta component (β) - orthogonal to alpha (90° ahead)\nPerforms Clarke transformation on given abc values …\nPerforms Clarke transformation using amplitude-invariant …\nPerforms the stateful Clarke transformation calculation.\nCreates a new Clarke transformation with default …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the Phase A input value.\nGets the alpha component output.\nGets the Phase B input value.\nGets the beta component output.\nGets the Phase C input value.\nGets the zero-sequence component output.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks if the three-phase system is balanced.\nCalculates the magnitude of the αβ vector.\nCreates a new Clarke transformation with specified initial …\nSets the three-phase input values for transformation.\nZero-sequence component (0) - common mode/unbalanced …\nInverse Clarke transformation for converting αβ0 …\nPerforms the inverse Clarke transformation calculation.\nCreates an inverse Clarke transformer with all values set …\nReturns the argument unchanged.\nGets the Phase A output value.\nGets the current alpha component input.\nGets the Phase B output value.\nGets the current beta component input.\nGets the Phase C output value.\nGets the current zero-sequence component input.\nCalls <code>U::from(self)</code>.\nCreates a new inverse Clarke transformer with specified …\nSets the input αβ0 components for transformation.\nInverse Park transformation for converting dq0 coordinates …\nPerforms the inverse Park transformation calculation.\nCreates an inverse Park transformer with all values set to …\nReturns the argument unchanged.\nGets the alpha component output.\nGets the beta component output.\nGets the cosine of the rotation angle.\nGets the direct axis (d) component input.\nGets the quadrature axis (q) component input.\nGets the sine of the rotation angle.\nGets the zero-sequence component input.\nGets the zero-sequence component.\nCalls <code>U::from(self)</code>.\nCreates a new inverse Park transformer with specified αβ …\nSets the rotation angle using sin and cos values.\nSets the input dq0 components for transformation.\nPark transformation for converting αβ0 coordinates to …\nPerforms the Park transformation calculation.\nCreates a Park transformer with all values set to zero.\nReturns the argument unchanged.\nGets the alpha component input.\nGets the beta component input.\nGets the cosine of the rotation angle.\nGets the direct axis (d) component output.\nGets the quadrature axis (q) component output.\nGets the sine of the rotation angle.\nGets the zero-sequence component output.\nGets the zero-sequence component.\nCalls <code>U::from(self)</code>.\nCreates a new Park transformer with specified αβ inputs.\nSets the rotation angle using sin and cos values.\nSets the input αβ0 components for transformation.")